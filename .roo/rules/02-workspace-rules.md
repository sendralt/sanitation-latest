Workspace-specific rules
General Guidelines for Programming Languages
Clarity and Readability

Favor straightforward, self-explanatory code structures across all languages.
Include descriptive comments to clarify complex logic.
Language-Specific Best Practices

Adhere to established community and project-specific best practices for each language (Python, JavaScript, Java, etc.).
Regularly review language documentation and style guides.
Consistency Across Codebases

Maintain uniform coding conventions and naming schemes across all languages used within a project.
Task Execution & Workflow
Task Definition & Steps
Specification

Define clear objectives, detailed requirements, user scenarios, and UI/UX standards.
Use advanced symbolic reasoning to analyze complex scenarios.
Pseudocode

Clearly map out logical implementation pathways before coding.
Architecture

Design modular, maintainable system components using appropriate technology stacks.
Ensure integration points are clearly defined for autonomous decision-making.
Refinement

Iteratively optimize code using autonomous feedback loops and stakeholder inputs.
Completion

Conduct rigorous testing, finalize comprehensive documentation, and deploy structured monitoring strategies.
AI Collaboration & Prompting
Clear Instructions

Provide explicit directives with defined outcomes, constraints, and contextual information.
Context Referencing

Regularly reference previous stages and decisions stored in the memory bank.
Suggest vs. Apply

Clearly indicate whether AI should propose ("Suggestion:") or directly implement changes ("Applying fix:").
Critical Evaluation

Thoroughly review all agentic outputs for accuracy and logical coherence.
Focused Interaction

Assign specific, clearly defined tasks to AI agents to maintain clarity.
Leverage Agent Strengths

Utilize AI for refactoring, symbolic reasoning, adaptive optimization, and test generation; human oversight remains on core logic and strategic architecture.
Incremental Progress

Break complex tasks into incremental, reviewable sub-steps.
Standard Check-in

Example: "Confirming understanding: Reviewed [context], goal is [goal], proceeding with [step]."
Advanced Coding Capabilities
Emergent Intelligence
AI autonomously maintains internal state models, supporting continuous refinement.
Pattern Recognition
Autonomous agents perform advanced pattern analysis for effective optimization.
Adaptive Optimization
Continuously evolving feedback loops refine the development process.
Symbolic Reasoning Integration
Symbolic Logic Integration
Combine symbolic logic with complexity analysis for robust decision-making.
Information Integration
Utilize symbolic mathematics and established software patterns for coherent implementations.
Coherent Documentation
Maintain clear, semantically accurate documentation through symbolic reasoning.
Code Quality & Style
Type Safety Guidelines

Use strong typing systems (TypeScript strict mode, Python type hints, Java generics, Rust ownership) and clearly document interfaces, function signatures, and complex logic.
Maintainability

Write modular, scalable code optimized for clarity and maintenance.
Concise Components

Keep files concise (under 500 lines) and proactively refactor.
Avoid Duplication (DRY)

Use symbolic reasoning to systematically identify redundancy.
Linting/Formatting

Consistently adhere to language-appropriate linting and formatting tools (ESLint/Prettier for JS/TS, Black/flake8 for Python, rustfmt for Rust, gofmt for Go).
File Naming

Use descriptive, permanent, and standardized naming conventions.
No One-Time Scripts

Avoid committing temporary utility scripts to production repositories.
Refactoring
Purposeful Changes

Refactor with clear objectives: improve readability, reduce redundancy, and meet architecture guidelines.
Holistic Approach

Consolidate similar components through symbolic analysis.
Direct Modification

Directly modify existing code rather than duplicating or creating temporary versions.
Integration Verification

Verify and validate all integrations after changes.
Testing & Validation
Test-Driven Development

Define and write tests before implementing features or fixes.
Comprehensive Coverage

Provide thorough test coverage for critical paths and edge cases.
Mandatory Passing

Immediately address any failing tests to maintain high-quality standards.
Manual Verification

Complement automated tests with structured manual checks.
Debugging & Troubleshooting
Root Cause Resolution

Employ symbolic reasoning to identify underlying causes of issues.
Targeted Logging

Integrate precise logging for efficient debugging.
Research Tools

Use advanced agentic tools (Perplexity, AIDER.chat, Firecrawl) to resolve complex issues efficiently.
Advanced Debugging Techniques

Apply binary search debugging for efficient issue isolation in large codebases.
Use differential debugging: compare working vs non-working states to identify differences.
Use state snapshot analysis for intermittent issues that are difficult to reproduce.
Security
Server-Side Authority

Maintain sensitive logic and data processing strictly server-side.
Input Sanitization

Enforce rigorous server-side input validation.
Credential Management

Securely manage credentials via environment variables; avoid any hardcoding.
Threat-Aware Design

Apply least privilege principle: grant minimum permissions necessary for component function.
Implement defense in depth: multiple security layers rather than single controls.
Version Control & Environment
Git Hygiene

Commit frequently with clear and descriptive messages.
Branching Strategy

Adhere strictly to defined branching guidelines.
Environment Management

Ensure code consistency and compatibility across all environments.
Server Management

Systematically restart servers following updates or configuration changes.
Documentation Maintenance
Reflective Documentation

Keep comprehensive, accurate, and logically structured documentation updated through symbolic reasoning.
Continuous Updates

Regularly revisit and refine guidelines to reflect evolving practices and accumulated project knowledge.
Performance & Reliability
Fault Tolerance Design

Implement graceful degradation: provide essential functionality during partial failures.
Apply circuit breaker patterns to prevent cascading failures in distributed systems.
Performance Optimization

Design for horizontal scaling through stateless architecture.
Apply caching strategies with consideration for cache invalidation and consistency.
Technical Decision Documentation
Architecture Decision Records (ADRs)

Document significant technical decisions with context, options considered, and rationale.
Track architectural evolution and decision impact over time.
Trade-off Analysis

Explicitly evaluate and document technical trade-offs in autonomous decision-making.
Consider reversibility: prefer decisions that maintain future options when facing uncertainty.
Legacy System Integration
Incremental Modernization
Apply strangler fig pattern: gradually replace legacy components by intercepting calls.
Implement anti-corruption layers between new and legacy systems for clean boundaries.
Project-specific rules
General Project Management
Each [PROJECT_NAME] maintains its own separate git repository